/* eslint-disable */
// @generated by protobuf-ts 2.9.4 with parameter add_pb_suffix,eslint_disable,ts_nocheck,use_proto_field_name
// @generated from protobuf file "diff.proto" (package "objdiff.diff", syntax proto3)
// tslint:disable
// @ts-nocheck
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * A symbol
 *
 * @generated from protobuf message objdiff.diff.Symbol
 */
export interface Symbol {
    /**
     * Name of the symbol
     *
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * Demangled name of the symbol
     *
     * @generated from protobuf field: optional string demangled_name = 2;
     */
    demangled_name?: string;
    /**
     * Symbol address
     *
     * @generated from protobuf field: uint64 address = 3;
     */
    address: bigint;
    /**
     * Symbol size
     *
     * @generated from protobuf field: uint64 size = 4;
     */
    size: bigint;
    /**
     * Bitmask of SymbolFlag
     *
     * @generated from protobuf field: uint32 flags = 5;
     */
    flags: number;
}
/**
 * A single parsed instruction
 *
 * @generated from protobuf message objdiff.diff.Instruction
 */
export interface Instruction {
    /**
     * Instruction address
     *
     * @generated from protobuf field: uint64 address = 1;
     */
    address: bigint;
    /**
     * Instruction size
     *
     * @generated from protobuf field: uint32 size = 2;
     */
    size: number;
    /**
     * Instruction opcode
     *
     * @generated from protobuf field: uint32 opcode = 3;
     */
    opcode: number;
    /**
     * Instruction mnemonic
     *
     * @generated from protobuf field: string mnemonic = 4;
     */
    mnemonic: string;
    /**
     * Instruction formatted string
     *
     * @generated from protobuf field: string formatted = 5;
     */
    formatted: string;
    /**
     * Original (unsimplified) instruction string
     *
     * @generated from protobuf field: optional string original = 6;
     */
    original?: string;
    /**
     * Instruction arguments
     *
     * @generated from protobuf field: repeated objdiff.diff.Argument arguments = 7;
     */
    arguments: Argument[];
    /**
     * Instruction relocation
     *
     * @generated from protobuf field: optional objdiff.diff.Relocation relocation = 8;
     */
    relocation?: Relocation;
    /**
     * Instruction branch destination
     *
     * @generated from protobuf field: optional uint64 branch_dest = 9;
     */
    branch_dest?: bigint;
    /**
     * Instruction line number
     *
     * @generated from protobuf field: optional uint32 line_number = 10;
     */
    line_number?: number;
}
/**
 * An instruction argument
 *
 * @generated from protobuf message objdiff.diff.Argument
 */
export interface Argument {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "plain_text";
        /**
         * Plain text
         *
         * @generated from protobuf field: string plain_text = 1;
         */
        plain_text: string;
    } | {
        oneofKind: "argument";
        /**
         * Value
         *
         * @generated from protobuf field: objdiff.diff.ArgumentValue argument = 2;
         */
        argument: ArgumentValue;
    } | {
        oneofKind: "relocation";
        /**
         * Relocation
         *
         * @generated from protobuf field: objdiff.diff.ArgumentRelocation relocation = 3;
         */
        relocation: ArgumentRelocation;
    } | {
        oneofKind: "branch_dest";
        /**
         * Branch destination
         *
         * @generated from protobuf field: uint64 branch_dest = 4;
         */
        branch_dest: bigint;
    } | {
        oneofKind: undefined;
    };
}
/**
 * An instruction argument value
 *
 * @generated from protobuf message objdiff.diff.ArgumentValue
 */
export interface ArgumentValue {
    /**
     * @generated from protobuf oneof: value
     */
    value: {
        oneofKind: "signed";
        /**
         * Signed integer
         *
         * @generated from protobuf field: int64 signed = 1;
         */
        signed: bigint;
    } | {
        oneofKind: "unsigned";
        /**
         * Unsigned integer
         *
         * @generated from protobuf field: uint64 unsigned = 2;
         */
        unsigned: bigint;
    } | {
        oneofKind: "opaque";
        /**
         * Opaque value
         *
         * @generated from protobuf field: string opaque = 3;
         */
        opaque: string;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Marker type for relocation arguments
 *
 * @generated from protobuf message objdiff.diff.ArgumentRelocation
 */
export interface ArgumentRelocation {
}
/**
 * @generated from protobuf message objdiff.diff.Relocation
 */
export interface Relocation {
    /**
     * @generated from protobuf field: uint32 type = 1;
     */
    type: number;
    /**
     * @generated from protobuf field: string type_name = 2;
     */
    type_name: string;
    /**
     * @generated from protobuf field: objdiff.diff.RelocationTarget target = 3;
     */
    target?: RelocationTarget;
}
/**
 * @generated from protobuf message objdiff.diff.RelocationTarget
 */
export interface RelocationTarget {
    /**
     * @generated from protobuf field: objdiff.diff.Symbol symbol = 1;
     */
    symbol?: Symbol;
    /**
     * @generated from protobuf field: int64 addend = 2;
     */
    addend: bigint;
}
/**
 * @generated from protobuf message objdiff.diff.InstructionDiff
 */
export interface InstructionDiff {
    /**
     * @generated from protobuf field: objdiff.diff.DiffKind diff_kind = 1;
     */
    diff_kind: DiffKind;
    /**
     * @generated from protobuf field: optional objdiff.diff.Instruction instruction = 2;
     */
    instruction?: Instruction;
    /**
     * @generated from protobuf field: optional objdiff.diff.InstructionBranchFrom branch_from = 3;
     */
    branch_from?: InstructionBranchFrom;
    /**
     * @generated from protobuf field: optional objdiff.diff.InstructionBranchTo branch_to = 4;
     */
    branch_to?: InstructionBranchTo;
    /**
     * @generated from protobuf field: repeated objdiff.diff.ArgumentDiff arg_diff = 5;
     */
    arg_diff: ArgumentDiff[];
}
/**
 * @generated from protobuf message objdiff.diff.ArgumentDiff
 */
export interface ArgumentDiff {
    /**
     * @generated from protobuf field: optional uint32 diff_index = 1;
     */
    diff_index?: number;
}
/**
 * @generated from protobuf message objdiff.diff.InstructionBranchFrom
 */
export interface InstructionBranchFrom {
    /**
     * @generated from protobuf field: repeated uint32 instruction_index = 1;
     */
    instruction_index: number[];
    /**
     * @generated from protobuf field: uint32 branch_index = 2;
     */
    branch_index: number;
}
/**
 * @generated from protobuf message objdiff.diff.InstructionBranchTo
 */
export interface InstructionBranchTo {
    /**
     * @generated from protobuf field: uint32 instruction_index = 1;
     */
    instruction_index: number;
    /**
     * @generated from protobuf field: uint32 branch_index = 2;
     */
    branch_index: number;
}
/**
 * @generated from protobuf message objdiff.diff.FunctionDiff
 */
export interface FunctionDiff {
    /**
     * @generated from protobuf field: objdiff.diff.Symbol symbol = 1;
     */
    symbol?: Symbol;
    /**
     * @generated from protobuf field: repeated objdiff.diff.InstructionDiff instructions = 2;
     */
    instructions: InstructionDiff[];
    /**
     * @generated from protobuf field: optional float match_percent = 3;
     */
    match_percent?: number;
}
/**
 * @generated from protobuf message objdiff.diff.DataDiff
 */
export interface DataDiff {
    /**
     * @generated from protobuf field: objdiff.diff.DiffKind kind = 1;
     */
    kind: DiffKind;
    /**
     * @generated from protobuf field: bytes data = 2;
     */
    data: Uint8Array;
    /**
     * May be larger than data
     *
     * @generated from protobuf field: uint64 size = 3;
     */
    size: bigint;
}
/**
 * @generated from protobuf message objdiff.diff.SectionDiff
 */
export interface SectionDiff {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: objdiff.diff.SectionKind kind = 2;
     */
    kind: SectionKind;
    /**
     * @generated from protobuf field: uint64 size = 3;
     */
    size: bigint;
    /**
     * @generated from protobuf field: uint64 address = 4;
     */
    address: bigint;
    /**
     * @generated from protobuf field: repeated objdiff.diff.FunctionDiff functions = 5;
     */
    functions: FunctionDiff[];
    /**
     * @generated from protobuf field: repeated objdiff.diff.DataDiff data = 6;
     */
    data: DataDiff[];
    /**
     * @generated from protobuf field: optional float match_percent = 7;
     */
    match_percent?: number;
}
/**
 * @generated from protobuf message objdiff.diff.ObjectDiff
 */
export interface ObjectDiff {
    /**
     * @generated from protobuf field: repeated objdiff.diff.SectionDiff sections = 1;
     */
    sections: SectionDiff[];
}
/**
 * @generated from protobuf message objdiff.diff.DiffResult
 */
export interface DiffResult {
    /**
     * @generated from protobuf field: optional objdiff.diff.ObjectDiff left = 1;
     */
    left?: ObjectDiff;
    /**
     * @generated from protobuf field: optional objdiff.diff.ObjectDiff right = 2;
     */
    right?: ObjectDiff;
}
/**
 * Symbol visibility flags
 *
 * @generated from protobuf enum objdiff.diff.SymbolFlag
 */
export enum SymbolFlag {
    /**
     * @generated from protobuf enum value: SYMBOL_NONE = 0;
     */
    SYMBOL_NONE = 0,
    /**
     * @generated from protobuf enum value: SYMBOL_GLOBAL = 1;
     */
    SYMBOL_GLOBAL = 1,
    /**
     * @generated from protobuf enum value: SYMBOL_LOCAL = 2;
     */
    SYMBOL_LOCAL = 2,
    /**
     * @generated from protobuf enum value: SYMBOL_WEAK = 3;
     */
    SYMBOL_WEAK = 3,
    /**
     * @generated from protobuf enum value: SYMBOL_COMMON = 4;
     */
    SYMBOL_COMMON = 4,
    /**
     * @generated from protobuf enum value: SYMBOL_HIDDEN = 5;
     */
    SYMBOL_HIDDEN = 5
}
/**
 * @generated from protobuf enum objdiff.diff.DiffKind
 */
export enum DiffKind {
    /**
     * @generated from protobuf enum value: DIFF_NONE = 0;
     */
    DIFF_NONE = 0,
    /**
     * @generated from protobuf enum value: DIFF_REPLACE = 1;
     */
    DIFF_REPLACE = 1,
    /**
     * @generated from protobuf enum value: DIFF_DELETE = 2;
     */
    DIFF_DELETE = 2,
    /**
     * @generated from protobuf enum value: DIFF_INSERT = 3;
     */
    DIFF_INSERT = 3,
    /**
     * @generated from protobuf enum value: DIFF_OP_MISMATCH = 4;
     */
    DIFF_OP_MISMATCH = 4,
    /**
     * @generated from protobuf enum value: DIFF_ARG_MISMATCH = 5;
     */
    DIFF_ARG_MISMATCH = 5
}
/**
 * @generated from protobuf enum objdiff.diff.SectionKind
 */
export enum SectionKind {
    /**
     * @generated from protobuf enum value: SECTION_UNKNOWN = 0;
     */
    SECTION_UNKNOWN = 0,
    /**
     * @generated from protobuf enum value: SECTION_TEXT = 1;
     */
    SECTION_TEXT = 1,
    /**
     * @generated from protobuf enum value: SECTION_DATA = 2;
     */
    SECTION_DATA = 2,
    /**
     * @generated from protobuf enum value: SECTION_BSS = 3;
     */
    SECTION_BSS = 3,
    /**
     * @generated from protobuf enum value: SECTION_COMMON = 4;
     */
    SECTION_COMMON = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class Symbol$Type extends MessageType<Symbol> {
    constructor() {
        super("objdiff.diff.Symbol", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "demangled_name", kind: "scalar", localName: "demangled_name", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "flags", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Symbol>): Symbol {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.address = 0n;
        message.size = 0n;
        message.flags = 0;
        if (value !== undefined)
            reflectionMergePartial<Symbol>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Symbol): Symbol {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* optional string demangled_name */ 2:
                    message.demangled_name = reader.string();
                    break;
                case /* uint64 address */ 3:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint64 size */ 4:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* uint32 flags */ 5:
                    message.flags = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Symbol, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* optional string demangled_name = 2; */
        if (message.demangled_name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.demangled_name);
        /* uint64 address = 3; */
        if (message.address !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.address);
        /* uint64 size = 4; */
        if (message.size !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.size);
        /* uint32 flags = 5; */
        if (message.flags !== 0)
            writer.tag(5, WireType.Varint).uint32(message.flags);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.Symbol
 */
export const Symbol = new Symbol$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instruction$Type extends MessageType<Instruction> {
    constructor() {
        super("objdiff.diff.Instruction", [
            { no: 1, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "size", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "opcode", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "mnemonic", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "formatted", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "original", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "arguments", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Argument },
            { no: 8, name: "relocation", kind: "message", T: () => Relocation },
            { no: 9, name: "branch_dest", kind: "scalar", localName: "branch_dest", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 10, name: "line_number", kind: "scalar", localName: "line_number", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Instruction>): Instruction {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = 0n;
        message.size = 0;
        message.opcode = 0;
        message.mnemonic = "";
        message.formatted = "";
        message.arguments = [];
        if (value !== undefined)
            reflectionMergePartial<Instruction>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instruction): Instruction {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint64 address */ 1:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* uint32 size */ 2:
                    message.size = reader.uint32();
                    break;
                case /* uint32 opcode */ 3:
                    message.opcode = reader.uint32();
                    break;
                case /* string mnemonic */ 4:
                    message.mnemonic = reader.string();
                    break;
                case /* string formatted */ 5:
                    message.formatted = reader.string();
                    break;
                case /* optional string original */ 6:
                    message.original = reader.string();
                    break;
                case /* repeated objdiff.diff.Argument arguments */ 7:
                    message.arguments.push(Argument.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional objdiff.diff.Relocation relocation */ 8:
                    message.relocation = Relocation.internalBinaryRead(reader, reader.uint32(), options, message.relocation);
                    break;
                case /* optional uint64 branch_dest */ 9:
                    message.branch_dest = reader.uint64().toBigInt();
                    break;
                case /* optional uint32 line_number */ 10:
                    message.line_number = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Instruction, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint64 address = 1; */
        if (message.address !== 0n)
            writer.tag(1, WireType.Varint).uint64(message.address);
        /* uint32 size = 2; */
        if (message.size !== 0)
            writer.tag(2, WireType.Varint).uint32(message.size);
        /* uint32 opcode = 3; */
        if (message.opcode !== 0)
            writer.tag(3, WireType.Varint).uint32(message.opcode);
        /* string mnemonic = 4; */
        if (message.mnemonic !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.mnemonic);
        /* string formatted = 5; */
        if (message.formatted !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.formatted);
        /* optional string original = 6; */
        if (message.original !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.original);
        /* repeated objdiff.diff.Argument arguments = 7; */
        for (let i = 0; i < message.arguments.length; i++)
            Argument.internalBinaryWrite(message.arguments[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional objdiff.diff.Relocation relocation = 8; */
        if (message.relocation)
            Relocation.internalBinaryWrite(message.relocation, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional uint64 branch_dest = 9; */
        if (message.branch_dest !== undefined)
            writer.tag(9, WireType.Varint).uint64(message.branch_dest);
        /* optional uint32 line_number = 10; */
        if (message.line_number !== undefined)
            writer.tag(10, WireType.Varint).uint32(message.line_number);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.Instruction
 */
export const Instruction = new Instruction$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Argument$Type extends MessageType<Argument> {
    constructor() {
        super("objdiff.diff.Argument", [
            { no: 1, name: "plain_text", kind: "scalar", localName: "plain_text", oneof: "value", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "argument", kind: "message", oneof: "value", T: () => ArgumentValue },
            { no: 3, name: "relocation", kind: "message", oneof: "value", T: () => ArgumentRelocation },
            { no: 4, name: "branch_dest", kind: "scalar", localName: "branch_dest", oneof: "value", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Argument>): Argument {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Argument>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Argument): Argument {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string plain_text */ 1:
                    message.value = {
                        oneofKind: "plain_text",
                        plain_text: reader.string()
                    };
                    break;
                case /* objdiff.diff.ArgumentValue argument */ 2:
                    message.value = {
                        oneofKind: "argument",
                        argument: ArgumentValue.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).argument)
                    };
                    break;
                case /* objdiff.diff.ArgumentRelocation relocation */ 3:
                    message.value = {
                        oneofKind: "relocation",
                        relocation: ArgumentRelocation.internalBinaryRead(reader, reader.uint32(), options, (message.value as any).relocation)
                    };
                    break;
                case /* uint64 branch_dest */ 4:
                    message.value = {
                        oneofKind: "branch_dest",
                        branch_dest: reader.uint64().toBigInt()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Argument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string plain_text = 1; */
        if (message.value.oneofKind === "plain_text")
            writer.tag(1, WireType.LengthDelimited).string(message.value.plain_text);
        /* objdiff.diff.ArgumentValue argument = 2; */
        if (message.value.oneofKind === "argument")
            ArgumentValue.internalBinaryWrite(message.value.argument, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* objdiff.diff.ArgumentRelocation relocation = 3; */
        if (message.value.oneofKind === "relocation")
            ArgumentRelocation.internalBinaryWrite(message.value.relocation, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 branch_dest = 4; */
        if (message.value.oneofKind === "branch_dest")
            writer.tag(4, WireType.Varint).uint64(message.value.branch_dest);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.Argument
 */
export const Argument = new Argument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArgumentValue$Type extends MessageType<ArgumentValue> {
    constructor() {
        super("objdiff.diff.ArgumentValue", [
            { no: 1, name: "signed", kind: "scalar", oneof: "value", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "unsigned", kind: "scalar", oneof: "value", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "opaque", kind: "scalar", oneof: "value", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ArgumentValue>): ArgumentValue {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.value = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ArgumentValue>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArgumentValue): ArgumentValue {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 signed */ 1:
                    message.value = {
                        oneofKind: "signed",
                        signed: reader.int64().toBigInt()
                    };
                    break;
                case /* uint64 unsigned */ 2:
                    message.value = {
                        oneofKind: "unsigned",
                        unsigned: reader.uint64().toBigInt()
                    };
                    break;
                case /* string opaque */ 3:
                    message.value = {
                        oneofKind: "opaque",
                        opaque: reader.string()
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArgumentValue, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 signed = 1; */
        if (message.value.oneofKind === "signed")
            writer.tag(1, WireType.Varint).int64(message.value.signed);
        /* uint64 unsigned = 2; */
        if (message.value.oneofKind === "unsigned")
            writer.tag(2, WireType.Varint).uint64(message.value.unsigned);
        /* string opaque = 3; */
        if (message.value.oneofKind === "opaque")
            writer.tag(3, WireType.LengthDelimited).string(message.value.opaque);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.ArgumentValue
 */
export const ArgumentValue = new ArgumentValue$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArgumentRelocation$Type extends MessageType<ArgumentRelocation> {
    constructor() {
        super("objdiff.diff.ArgumentRelocation", []);
    }
    create(value?: PartialMessage<ArgumentRelocation>): ArgumentRelocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ArgumentRelocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArgumentRelocation): ArgumentRelocation {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ArgumentRelocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.ArgumentRelocation
 */
export const ArgumentRelocation = new ArgumentRelocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Relocation$Type extends MessageType<Relocation> {
    constructor() {
        super("objdiff.diff.Relocation", [
            { no: 1, name: "type", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "type_name", kind: "scalar", localName: "type_name", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "target", kind: "message", T: () => RelocationTarget }
        ]);
    }
    create(value?: PartialMessage<Relocation>): Relocation {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.type = 0;
        message.type_name = "";
        if (value !== undefined)
            reflectionMergePartial<Relocation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Relocation): Relocation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 type */ 1:
                    message.type = reader.uint32();
                    break;
                case /* string type_name */ 2:
                    message.type_name = reader.string();
                    break;
                case /* objdiff.diff.RelocationTarget target */ 3:
                    message.target = RelocationTarget.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Relocation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 type = 1; */
        if (message.type !== 0)
            writer.tag(1, WireType.Varint).uint32(message.type);
        /* string type_name = 2; */
        if (message.type_name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.type_name);
        /* objdiff.diff.RelocationTarget target = 3; */
        if (message.target)
            RelocationTarget.internalBinaryWrite(message.target, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.Relocation
 */
export const Relocation = new Relocation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RelocationTarget$Type extends MessageType<RelocationTarget> {
    constructor() {
        super("objdiff.diff.RelocationTarget", [
            { no: 1, name: "symbol", kind: "message", T: () => Symbol },
            { no: 2, name: "addend", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RelocationTarget>): RelocationTarget {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.addend = 0n;
        if (value !== undefined)
            reflectionMergePartial<RelocationTarget>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RelocationTarget): RelocationTarget {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* objdiff.diff.Symbol symbol */ 1:
                    message.symbol = Symbol.internalBinaryRead(reader, reader.uint32(), options, message.symbol);
                    break;
                case /* int64 addend */ 2:
                    message.addend = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RelocationTarget, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* objdiff.diff.Symbol symbol = 1; */
        if (message.symbol)
            Symbol.internalBinaryWrite(message.symbol, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int64 addend = 2; */
        if (message.addend !== 0n)
            writer.tag(2, WireType.Varint).int64(message.addend);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.RelocationTarget
 */
export const RelocationTarget = new RelocationTarget$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDiff$Type extends MessageType<InstructionDiff> {
    constructor() {
        super("objdiff.diff.InstructionDiff", [
            { no: 1, name: "diff_kind", kind: "enum", localName: "diff_kind", T: () => ["objdiff.diff.DiffKind", DiffKind] },
            { no: 2, name: "instruction", kind: "message", T: () => Instruction },
            { no: 3, name: "branch_from", kind: "message", localName: "branch_from", T: () => InstructionBranchFrom },
            { no: 4, name: "branch_to", kind: "message", localName: "branch_to", T: () => InstructionBranchTo },
            { no: 5, name: "arg_diff", kind: "message", localName: "arg_diff", repeat: 1 /*RepeatType.PACKED*/, T: () => ArgumentDiff }
        ]);
    }
    create(value?: PartialMessage<InstructionDiff>): InstructionDiff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.diff_kind = 0;
        message.arg_diff = [];
        if (value !== undefined)
            reflectionMergePartial<InstructionDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDiff): InstructionDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* objdiff.diff.DiffKind diff_kind */ 1:
                    message.diff_kind = reader.int32();
                    break;
                case /* optional objdiff.diff.Instruction instruction */ 2:
                    message.instruction = Instruction.internalBinaryRead(reader, reader.uint32(), options, message.instruction);
                    break;
                case /* optional objdiff.diff.InstructionBranchFrom branch_from */ 3:
                    message.branch_from = InstructionBranchFrom.internalBinaryRead(reader, reader.uint32(), options, message.branch_from);
                    break;
                case /* optional objdiff.diff.InstructionBranchTo branch_to */ 4:
                    message.branch_to = InstructionBranchTo.internalBinaryRead(reader, reader.uint32(), options, message.branch_to);
                    break;
                case /* repeated objdiff.diff.ArgumentDiff arg_diff */ 5:
                    message.arg_diff.push(ArgumentDiff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* objdiff.diff.DiffKind diff_kind = 1; */
        if (message.diff_kind !== 0)
            writer.tag(1, WireType.Varint).int32(message.diff_kind);
        /* optional objdiff.diff.Instruction instruction = 2; */
        if (message.instruction)
            Instruction.internalBinaryWrite(message.instruction, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional objdiff.diff.InstructionBranchFrom branch_from = 3; */
        if (message.branch_from)
            InstructionBranchFrom.internalBinaryWrite(message.branch_from, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional objdiff.diff.InstructionBranchTo branch_to = 4; */
        if (message.branch_to)
            InstructionBranchTo.internalBinaryWrite(message.branch_to, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated objdiff.diff.ArgumentDiff arg_diff = 5; */
        for (let i = 0; i < message.arg_diff.length; i++)
            ArgumentDiff.internalBinaryWrite(message.arg_diff[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.InstructionDiff
 */
export const InstructionDiff = new InstructionDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ArgumentDiff$Type extends MessageType<ArgumentDiff> {
    constructor() {
        super("objdiff.diff.ArgumentDiff", [
            { no: 1, name: "diff_index", kind: "scalar", localName: "diff_index", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ArgumentDiff>): ArgumentDiff {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ArgumentDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ArgumentDiff): ArgumentDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 diff_index */ 1:
                    message.diff_index = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ArgumentDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 diff_index = 1; */
        if (message.diff_index !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.diff_index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.ArgumentDiff
 */
export const ArgumentDiff = new ArgumentDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionBranchFrom$Type extends MessageType<InstructionBranchFrom> {
    constructor() {
        super("objdiff.diff.InstructionBranchFrom", [
            { no: 1, name: "instruction_index", kind: "scalar", localName: "instruction_index", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "branch_index", kind: "scalar", localName: "branch_index", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InstructionBranchFrom>): InstructionBranchFrom {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instruction_index = [];
        message.branch_index = 0;
        if (value !== undefined)
            reflectionMergePartial<InstructionBranchFrom>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionBranchFrom): InstructionBranchFrom {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 instruction_index */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.instruction_index.push(reader.uint32());
                    else
                        message.instruction_index.push(reader.uint32());
                    break;
                case /* uint32 branch_index */ 2:
                    message.branch_index = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionBranchFrom, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 instruction_index = 1; */
        if (message.instruction_index.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.instruction_index.length; i++)
                writer.uint32(message.instruction_index[i]);
            writer.join();
        }
        /* uint32 branch_index = 2; */
        if (message.branch_index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.branch_index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.InstructionBranchFrom
 */
export const InstructionBranchFrom = new InstructionBranchFrom$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionBranchTo$Type extends MessageType<InstructionBranchTo> {
    constructor() {
        super("objdiff.diff.InstructionBranchTo", [
            { no: 1, name: "instruction_index", kind: "scalar", localName: "instruction_index", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "branch_index", kind: "scalar", localName: "branch_index", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<InstructionBranchTo>): InstructionBranchTo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instruction_index = 0;
        message.branch_index = 0;
        if (value !== undefined)
            reflectionMergePartial<InstructionBranchTo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionBranchTo): InstructionBranchTo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 instruction_index */ 1:
                    message.instruction_index = reader.uint32();
                    break;
                case /* uint32 branch_index */ 2:
                    message.branch_index = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionBranchTo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 instruction_index = 1; */
        if (message.instruction_index !== 0)
            writer.tag(1, WireType.Varint).uint32(message.instruction_index);
        /* uint32 branch_index = 2; */
        if (message.branch_index !== 0)
            writer.tag(2, WireType.Varint).uint32(message.branch_index);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.InstructionBranchTo
 */
export const InstructionBranchTo = new InstructionBranchTo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FunctionDiff$Type extends MessageType<FunctionDiff> {
    constructor() {
        super("objdiff.diff.FunctionDiff", [
            { no: 1, name: "symbol", kind: "message", T: () => Symbol },
            { no: 2, name: "instructions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => InstructionDiff },
            { no: 3, name: "match_percent", kind: "scalar", localName: "match_percent", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<FunctionDiff>): FunctionDiff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.instructions = [];
        if (value !== undefined)
            reflectionMergePartial<FunctionDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FunctionDiff): FunctionDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* objdiff.diff.Symbol symbol */ 1:
                    message.symbol = Symbol.internalBinaryRead(reader, reader.uint32(), options, message.symbol);
                    break;
                case /* repeated objdiff.diff.InstructionDiff instructions */ 2:
                    message.instructions.push(InstructionDiff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float match_percent */ 3:
                    message.match_percent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FunctionDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* objdiff.diff.Symbol symbol = 1; */
        if (message.symbol)
            Symbol.internalBinaryWrite(message.symbol, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated objdiff.diff.InstructionDiff instructions = 2; */
        for (let i = 0; i < message.instructions.length; i++)
            InstructionDiff.internalBinaryWrite(message.instructions[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional float match_percent = 3; */
        if (message.match_percent !== undefined)
            writer.tag(3, WireType.Bit32).float(message.match_percent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.FunctionDiff
 */
export const FunctionDiff = new FunctionDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DataDiff$Type extends MessageType<DataDiff> {
    constructor() {
        super("objdiff.diff.DataDiff", [
            { no: 1, name: "kind", kind: "enum", T: () => ["objdiff.diff.DiffKind", DiffKind] },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<DataDiff>): DataDiff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.kind = 0;
        message.data = new Uint8Array(0);
        message.size = 0n;
        if (value !== undefined)
            reflectionMergePartial<DataDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DataDiff): DataDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* objdiff.diff.DiffKind kind */ 1:
                    message.kind = reader.int32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                case /* uint64 size */ 3:
                    message.size = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DataDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* objdiff.diff.DiffKind kind = 1; */
        if (message.kind !== 0)
            writer.tag(1, WireType.Varint).int32(message.kind);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        /* uint64 size = 3; */
        if (message.size !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.size);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.DataDiff
 */
export const DataDiff = new DataDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SectionDiff$Type extends MessageType<SectionDiff> {
    constructor() {
        super("objdiff.diff.SectionDiff", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "kind", kind: "enum", T: () => ["objdiff.diff.SectionKind", SectionKind] },
            { no: 3, name: "size", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "address", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "functions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => FunctionDiff },
            { no: 6, name: "data", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => DataDiff },
            { no: 7, name: "match_percent", kind: "scalar", localName: "match_percent", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<SectionDiff>): SectionDiff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.kind = 0;
        message.size = 0n;
        message.address = 0n;
        message.functions = [];
        message.data = [];
        if (value !== undefined)
            reflectionMergePartial<SectionDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SectionDiff): SectionDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* objdiff.diff.SectionKind kind */ 2:
                    message.kind = reader.int32();
                    break;
                case /* uint64 size */ 3:
                    message.size = reader.uint64().toBigInt();
                    break;
                case /* uint64 address */ 4:
                    message.address = reader.uint64().toBigInt();
                    break;
                case /* repeated objdiff.diff.FunctionDiff functions */ 5:
                    message.functions.push(FunctionDiff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated objdiff.diff.DataDiff data */ 6:
                    message.data.push(DataDiff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float match_percent */ 7:
                    message.match_percent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SectionDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* objdiff.diff.SectionKind kind = 2; */
        if (message.kind !== 0)
            writer.tag(2, WireType.Varint).int32(message.kind);
        /* uint64 size = 3; */
        if (message.size !== 0n)
            writer.tag(3, WireType.Varint).uint64(message.size);
        /* uint64 address = 4; */
        if (message.address !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.address);
        /* repeated objdiff.diff.FunctionDiff functions = 5; */
        for (let i = 0; i < message.functions.length; i++)
            FunctionDiff.internalBinaryWrite(message.functions[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated objdiff.diff.DataDiff data = 6; */
        for (let i = 0; i < message.data.length; i++)
            DataDiff.internalBinaryWrite(message.data[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional float match_percent = 7; */
        if (message.match_percent !== undefined)
            writer.tag(7, WireType.Bit32).float(message.match_percent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.SectionDiff
 */
export const SectionDiff = new SectionDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ObjectDiff$Type extends MessageType<ObjectDiff> {
    constructor() {
        super("objdiff.diff.ObjectDiff", [
            { no: 1, name: "sections", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => SectionDiff }
        ]);
    }
    create(value?: PartialMessage<ObjectDiff>): ObjectDiff {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.sections = [];
        if (value !== undefined)
            reflectionMergePartial<ObjectDiff>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ObjectDiff): ObjectDiff {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated objdiff.diff.SectionDiff sections */ 1:
                    message.sections.push(SectionDiff.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ObjectDiff, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated objdiff.diff.SectionDiff sections = 1; */
        for (let i = 0; i < message.sections.length; i++)
            SectionDiff.internalBinaryWrite(message.sections[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.ObjectDiff
 */
export const ObjectDiff = new ObjectDiff$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DiffResult$Type extends MessageType<DiffResult> {
    constructor() {
        super("objdiff.diff.DiffResult", [
            { no: 1, name: "left", kind: "message", T: () => ObjectDiff },
            { no: 2, name: "right", kind: "message", T: () => ObjectDiff }
        ]);
    }
    create(value?: PartialMessage<DiffResult>): DiffResult {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<DiffResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiffResult): DiffResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional objdiff.diff.ObjectDiff left */ 1:
                    message.left = ObjectDiff.internalBinaryRead(reader, reader.uint32(), options, message.left);
                    break;
                case /* optional objdiff.diff.ObjectDiff right */ 2:
                    message.right = ObjectDiff.internalBinaryRead(reader, reader.uint32(), options, message.right);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiffResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional objdiff.diff.ObjectDiff left = 1; */
        if (message.left)
            ObjectDiff.internalBinaryWrite(message.left, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional objdiff.diff.ObjectDiff right = 2; */
        if (message.right)
            ObjectDiff.internalBinaryWrite(message.right, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message objdiff.diff.DiffResult
 */
export const DiffResult = new DiffResult$Type();
